---
title: "ENMeval 2.0.5 Vignette"
author: "Jamie M. Kass, Robert Muscarella, Gonzalo E. Pinilla-Buitrago, and Peter J. Galante"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{ENMeval 2.0.5 Vignette}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup, echo = FALSE, include = FALSE}
library(knitr)
library(terra)
knitr::opts_chunk$set(collapse = TRUE, message = FALSE, warning = FALSE, eval = TRUE, comment = "#>", fig.width = 7, fig.height = 7)
options(terra.pal = map.pal("plasma", 100))
```

- [Introduction](#intro)
- [Data Acquisition & Pre-processing](#data)
- [Partitioning Occurrences for Evaluation](#partition)
- [Running ENMeval](#eval)
- [Model Selection](#select)
- [Plotting results](#plot)
- [Null Models](#null)
- [Metadata](#metadata)
- [References and Resources](#resources)


## Introduction {#intro}

* To align with the new `ENMeval` 2.0.5, this version updates the vignette by replacing `raster` functions with those from `terra`, and `dismo` functions with those from `predicts`. These updates were made by G. E. Pinilla-Buitrago.

[`ENMeval`](https://cran.r-project.org/package=ENMeval) is an R package that performs automated tuning and evaluations of ecological niche models (ENMs, a.k.a. species distribution models or SDMs), which can estimate species' ranges and niche characteristics using data on species occurrences and environmental variables (Franklin 2010, Peterson et al. 2011, Guisan et al. 2017). 

Some of the most frequently used ENMs are machine learning algorithms with settings that can be "tuned" to determine optimal levels of model complexity (Hastie et al. 2009, Radosavljevic & Anderson 2014, Hallgren et al. 2019). In implementation, this means building models of varying settings, then evaluating them and comparing their performance to select the optimal settings. Such tuning exercises can result in models that balance goodness-of-fit (i.e., avoiding overfitting) and predictive ability. Model evaluation is often done with cross-validation, which consists of partitioning the data into groups, building a model with all the groups but one, evaluating this model on the left-out group, then repeating the process until all groups have been left out once (Hastie et al. 2009, Roberts et al. 2017).

`ENMeval` has one primary function, `ENMevaluate`, which runs the tuning analysis and evaluations, returning an `ENMevaluation` object that contains the results. These results include a table of evaluation statistics, fitted model objects, and prediction rasters for each combination of model settings. The older versions of `ENMeval` (0.3.0 and earlier; Muscarella et al. 2014) implemented only the ENM presence-background algorithm Maxent through the Java software [maxent.jar](http://biodiversityinformatics.amnh.org/open_source/maxent/) and the R package  [`maxnet`](https://cran.r-project.org/package=maxnet), but `ENMeval` 2.0.x offers functionality for adding and customizing the implementations of ENM algorithms and their evaluations. This new version also features automatic generation of metadata, a null model for calculating effect size and significance of performance metrics, various plotting tools, options for parallel computing, and more.  
In this updated vignette, we detail a full ENM analysis: acquisition and processing of input data, sampling background data, deciding on partitioning methods, tuning models, examining results and selecting optimal model settings, building null models to test for significance of performance metrics, and more using `ENMeval` 2.0.x and other relevant R packages. In addition to this vignette, there are other excellent tutorials on ENMs, some of which can be found in the [References and Resources](#resources) section.

## Data Acquisition & Pre-processing {#data}

We'll start by downloading an occurrence dataset for [*Bradypus variegatus*](https://en.wikipedia.org/wiki/Brown-throated_sloth), the brown-throated sloth. Along the way, if you notice you cannot load a particular package, simply install it with `install.packages`, then try `library` again.

```{r occDownload}
# Load packages -- the order here is important because some pkg functions overwrite others.
library(ENMeval)
library(terra)
library(dplyr)

# Set a random seed in order to be able to reproduce this analysis.
set.seed(48)

# You can search online databases like GBIF using the spocc package (commented below),
# but here we will load in some pre-downloaded data.
# bv <- spocc::occ('Bradypus variegatus', 'gbif', limit=300, has_coords = TRUE)
# occs <- as.data.frame(bv$gbif$data$Bradypus_variegatus[,2:3])
occs <- readRDS("bvariegatus.rds")

# Removing occurrences that have the same coordinates is good practice to
# avoid pseudoreplication.
occs <- occs[!duplicated(occs),]
```

We are going to model the climatic niche suitability for our focal species using long-term summarized climate data from [WorldClim 2.1](http://www.worldclim.org/). WorldClim has a range of variables available at various resolutions; for simplicity, here we'll use the 19 bioclimatic variables at 5 arcmin resolution (about 10 km across at the equator) downloadable using the `geodata` package. Many of these variables are often highly correlated, and modeling with correlated variables can lead to inaccurate results (even with machine-learning methods that are robust to collinearity), so we will remove those with the highest variance inflation factor (VIF), a measure of variable correlation.

```{r envDownload, warning = FALSE, message = FALSE}
# Download global raster data for bioclimatic variables from WorldClim 2.1, then
# simplify their names and crop them to our extent of interest.
# Find the descriptions of the bioclimatic variables here: 
# https://www.worldclim.org/data/bioclim.html
envs <- geodata::worldclim_global(var = "bio", res = 5, path = ".")
names(envs) <- paste("bio", 1:19, sep = "")
extent <- ext(-125, -32, -56, 40)
envs <- crop(envs, extent)
# Now we will remove those variables from consideration that have a high VIF.
envs.vif <- usdm::vifstep(envs)
envs.rem <- envs.vif@excluded
envs <- envs[[!(names(envs) %in% envs.rem)]]

# Let's now remove occurrences that are cell duplicates -- these are
# occurrences that share a grid cell in the predictor variable rasters.
# Although Maxent does this by default, keep in mind that for other algorithms you may
# or may not want to do this based on the aims of your study.
# Another way to space occurrence records a defined distance from each other to avoid
# spatial autocorrelation is with spatial thinning (Aiello-Lammens et al. 2015).
occs.cells <- terra::extract(envs[[1]], occs, cellnumbers = TRUE, ID = FALSE)
occs.cellDups <- duplicated(occs.cells[,1])
occs <- occs[!occs.cellDups,]

# Plot first raster in the stack, the mean annual temperature.
plot(envs[[1]], main="Mean annual temperature")

# Add points for all the occurrence points onto the raster.
points(occs)

# There are some points east of the Amazon River.
# Suppose we know this is a population that we don't want to include in the model.
# We can remove these points from the analysis by subsetting the occurrences by 
# latitude and longitude.
occs <- filter(occs, latitude > -20, longitude < -45)

# Plot the subsetted occurrences to make sure we filtered correctly.
points(occs)
```

Now let's take a look at which areas of this extent are climatically different with respect to the areas associated with the occurrence points. To do this, we'll use the Multivariate Environmental Similarity surface, or MESS (Elith et al. 2010). Higher positive values indicate increasing similarity, while higher negative values indicate dissimilarity. Other methods besides MESS have also been proposed and warrant exploration (e.g., Owens et al. 2013, Mesgaran et al. 2014). This is important to investigate when considering model transfer to other times or places, as environments that are extremely dissimilar to those used to train the model in the present can result in projections with high uncertainty (Wenger & Olden 2012, Wright et al. 2015, Soley-Guardia 2019).

Although the `mess` function from the `predicts` package is frequently used, here we will use tools from the package [`rmaxent`](https://github.com/johnbaums/rmaxent) (Baumgartner & Wilson 2021) because it also plots maps of the most similar and dissimilar variables -- this functionality is currently included in `ENMeval` in the `similarity` function. We will demonstrate the `ENMeval` plotting functions for environmental similarity later.

```{r}
# First we extract the climatic variable values at the occurrence points -- 
# these values are our "reference". Let's first remove the occurrences with
# NA values for our environmental variable rasters.
occs.z <- terra::extract(envs, occs, ID = FALSE)
occs.na <- which(rowSums(is.na(occs.z)) > 0)
occs <- occs[-occs.na,]
occs.z <- na.omit(occs.z)
# Now we use the similarity() function (borrowed from the rmaxent package) to calculate 
# environmental similarity metrics of our predictor variable extent compared to the reference
# points.
occs.sim <- ENMeval::similarity(envs, occs.z)
occs.mess <- occs.sim$similarity_min
# This is the MESS plot -- increasingly negative values represent increasingly different 
# climatic conditions from the reference (our occurrences), while increasingly positive 
# values are more similar.
plot(occs.mess, main = "Environmental similarity")
points(occs)
# Here we define some good colors for representing categorical variables
cols <- RColorBrewer::brewer.pal(10, "Set3")
# This map shows the variable for each grid cell that is most different from the reference
plot(occs.sim$mod, col = cols, main = "Most different variable")
# This map shows the variable for each grid cell that is most similar to the reference
plot(occs.sim$mos, col = cols, main = "Most similar variable")
```

Since our models will compare the environment at occurrence localities to the environment at background localities, we need to sample random points from a background extent. Now we will specify the study extent that defines where we sample background data by cropping our global predictor variable rasters to a smaller region. To help ensure we do not include areas that are suitable for our species but are unoccupied due to limitations like dispersal constraints, we will conservatively define the background extent as an area surrounding our occurrence localities (VanDerWal et al. 2009, Merow et al. 2013). We will do this by buffering a bounding box that includes all occurrence localities. Some other methods of background extent delineation (e.g., minimum convex hulls) are more conservative because they better characterize the geographic space holding the points. In any case, this is one of the many things that you will need to carefully consider for your own study.

```{r backgExt, message = FALSE, warning = FALSE}
# We'll now experiment with a different spatial R package called sf (simple features).
# Let's make our occs into a sf object -- as the coordinate reference system (crs) for these 
# points is WGS84, a geographic crs (lat/lon) and the same as our envs rasters, we specify it 
# as the SpatRaster's crs.
occs.sf <- sf::st_as_sf(occs, coords = c("longitude","latitude"), crs = terra::crs(envs))

# Now, we project our point data to an equal-area projection, which converts our 
# degrees to meters, which is ideal for buffering (the next step). 
# We use the typical Eckert IV projection.
eckertIV <- "+proj=eck4 +lon_0=0 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs"
occs.sf <- sf::st_transform(occs.sf, crs = eckertIV)

# Buffer all occurrences by 500 km, union the polygons together 
# (for visualization), and convert back to a form that the terra package 
# can use. Finally, we reproject the buffers back to WGS84 (lat/lon).
# We choose 500 km here to avoid sampling the Caribbean islands.
occs.buf <- sf::st_buffer(occs.sf, dist = 500000) |> 
  sf::st_union() |> 
  sf::st_sf() |>
  sf::st_transform(crs = raster::crs(envs))
plot(envs[[1]], main = names(envs)[1])
points(occs)
# To add sf objects to a plot, use add = TRUE
plot(occs.buf, border = "blue", lwd = 3, add = TRUE)

# Crop environmental rasters to match the study extent
envs.bg <- terra::crop(envs, occs.buf)
# Next, mask the rasters to the shape of the buffers
envs.bg <- terra::mask(envs.bg, occs.buf)
plot(envs.bg[[1]], main = names(envs)[1])
points(occs)
plot(occs.buf, border = "blue", lwd = 3, add = TRUE)
```

In the next step, we'll sample 10,000 random points from the background (note that the number of background points is also a consideration you should make with respect to your own study).

```{r backgPts}
# Randomly sample 10,000 background points from one background extent raster 
# (only one per cell without replacement). Note: Since the raster has <10,000 pixels, 
# you'll get a warning and all pixels will be used for background.
bg <- predicts::backgroundSample(envs.bg, n = 10000) |> as.data.frame()
colnames(bg) <- colnames(occs)

# Notice how we have pretty good coverage (every cell).
plot(envs.bg[[1]])
points(bg, pch = 20, cex = 0.2)
```

## Partitioning Occurrences for Evaluation {#partition}
A run of `ENMevaluate` begins by using one of seven methods to partition occurrence localities into validation and training bins (folds) for *k*-fold cross-validation (Fielding & Bell 1997, Hastie et al. 2009, Peterson et al. 2011). Data partitioning is done internally by `ENMevaluate` based on what the user inputs for the `partitions` argument, but this can also be done externally using the partitioning functions. In this section, we explain and illustrate these different functions. We also demonstrate how to make informative plots of partitions and the environmental similarity of partitions to the background or study extent.

1. [Spatial Block](#block)
2. [Spatial Checkerboard](#cb1)
3. [Spatial Hierarchical Checkerboard](#cb2)
4. [Jackknife (leave-one-out)](#jack)
5. [Random *k*-fold](#rand)
6. [Fully Withheld Testing Data](#testing)
7. [User](#user)

The first three partitioning methods are variations of what Radosavljevic and Anderson (2014) referred to as 'masked geographically structured' data partitioning. Basically, these methods partition both occurrence and background records into evaluation bins based on spatial rules. The intention is to reduce spatial-autocorrelation between points that are included in the validation and training bins, which can overinflate model performance, at least for data sets that result from biased sampling (Veloz 2009, Wenger & Olden 2012, Roberts et al. 2017). Other spatial partitioning methods for ENMs can be found in the R package `blockCV` (Valavi et al. 2019), which we demonstrate below for use with `ENMeval`.

#### 1. Block {#block}
First, the 'block' method partitions data according to the latitude and longitude lines that divide the occurrence localities into four spatial groups of equal numbers (or as close as possible). Both occurrence and background localities are assigned to each of the four bins based on their position with respect to these lines -- the first direction bisects the points into two groups, and the second direction bisects each of these further into two groups each, resulting in four groups. The resulting object is a list of two vectors that supply the bin designation for each occurrence and background point. In `ENMeval` 2.0.x, users can additionally specify different orientations for the blocking with the `orientation` argument.

```{r part.block}
block <- get.block(occs, bg, orientation = "lat_lon")
# Let's make sure that we have an even number of occurrences in each partition.
table(block$occs.grp)
# We can plot our partitions on one of our predictor variable rasters to visualize 
# where they fall in space.
# The ENMeval 2.0.x plotting functions use ggplot2 (Wickham 2016), a popular plotting 
# package for R with many online resources.
# We can add to the ggplots with other ggplot functions in an additive way, making 
# these plots easily customizable.
evalplot.grps(pts = occs, pts.grp = block$occs.grp, envs = envs.bg) + 
  ggplot2::ggtitle("Spatial block partitions: occurrences")
# PLotting the background shows that the background extent is partitioned in a way 
# that maximizes evenness of points across the four bins, not to maximize evenness of area.
evalplot.grps(pts = bg, pts.grp = block$bg.grp, envs = envs.bg) + 
  ggplot2::ggtitle("Spatial block partitions: background")

# If we are curious how different the environment associated with each partition is from 
# that of all the others, we can use this function to plot histograms or rasters of MESS 
# predictions with each partition as the reference.
# First we need to extract the predictor variable values at our occurrence and 
# background localities.
occs.z <- cbind(occs, terra::extract(envs, occs, ID = FALSE))
bg.z <- cbind(bg, terra::extract(envs, bg, ID = FALSE))
evalplot.envSim.hist(sim.type = "mess", ref.data = "occs", occs.z = occs.z, bg.z = bg.z, 
                     occs.grp = block$occs.grp, bg.grp = block$bg.grp)
evalplot.envSim.hist(sim.type = "most_diff", ref.data = "occs", occs.z = occs.z, bg.z = bg.z, 
                     occs.grp = block$occs.grp, bg.grp = block$bg.grp)
evalplot.envSim.hist(sim.type = "most_sim", ref.data = "occs", occs.z = occs.z, bg.z = bg.z, 
                     occs.grp = block$occs.grp, bg.grp = block$bg.grp)

# Here we plot environmental similarity values for the entire extent with respect 
# to each validation group.
# We use the bb.buf (bounding box buffer) argument to zoom in to our study extent.
evalplot.envSim.map(sim.type = "mess", ref.data = "occs", envs = envs, occs.z = occs.z, 
                    bg.z = bg.z, occs.grp = block$occs.grp, 
                    bg.grp = block$bg.grp, bb.buf = 7)
evalplot.envSim.map(sim.type = "most_diff", ref.data = "occs", envs = envs, 
                    occs.z = occs.z, bg.z = bg.z, 
                    occs.grp = block$occs.grp, bg.grp = block$bg.grp, 
                    sim.palette = "Set3", bb.buf = 7)
evalplot.envSim.map(sim.type = "most_sim", ref.data = "occs", envs = envs, 
                    occs.z = occs.z, bg.z = bg.z, 
                    occs.grp = block$occs.grp, bg.grp = block$bg.grp, 
                    sim.palette = "Set3", bb.buf = 7)
```

#### 2. Basic checkerboard {#cb1}
The next two partitioning methods are variants of a checkerboard approach to partition occurrence localities (Radosavljevic & Anderson 2014). These generate checkerboard grids across the study extent and partition the localities into groups based on where they fall on the checkerboard. In contrast to the block method, both checkerboard methods subdivide geographic space equally but do not ensure a balanced number of occurrence localities in each bin. For these methods, the user needs to provide a raster layer on which to base the underlying checkerboard pattern. Here we simply use the predictor variable SpatRaster. Additionally, the user needs to define an *aggregation.factor*. This value specifies the number of grids cells to aggregate when making the underlying checkerboard pattern.

The basic checkerboard method partitions the points into *k* = 2 spatial groups using a simple checkerboard pattern.

```{r part.ck1}
cb1 <- get.checkerboard(occs, envs.bg, bg, aggregation.factor = 5)
evalplot.grps(pts = occs, pts.grp = cb1$occs.grp, envs = envs.bg)
# Plotting the background points shows the checkerboard pattern clearly.
evalplot.grps(pts = bg, pts.grp = cb1$bg.grp, envs = envs.bg)
# We can see from the MESS maps that this method results in similar environmental 
# representation between the partitions.
evalplot.envSim.hist(sim.type = "mess", ref.data = "occs", occs.z = occs.z, bg.z = bg.z, 
                     occs.grp = cb1$occs.grp, bg.grp = cb1$bg.grp)
```

```{r fig.width = 7, fig.height = 5}
evalplot.envSim.map(sim.type = "mess", ref.data = "occs", envs = envs, occs.z = occs.z, 
                    bg.z = bg.z, occs.grp = cb1$occs.grp, 
                    bg.grp = cb1$bg.grp, bb.buf = 7)
```

```{r}
# We can increase the aggregation factor to give the groups bigger boxes.
# This can result in groups that are more environmentally different from each other.
cb1.large <- get.checkerboard(occs, envs.bg, bg, aggregation.factor = 30)
evalplot.grps(pts = occs, pts.grp = cb1.large$occs.grp, envs = envs.bg)
evalplot.grps(pts = bg, pts.grp = cb1.large$bg.grp, envs = envs.bg)
evalplot.envSim.hist(sim.type = "mess", ref.data = "occs", occs.z = occs.z, 
                     bg.z = bg.z, occs.grp = cb1.large$occs.grp, bg.grp = cb1$bg.grp)
```

```{r fig.width = 7, fig.height = 5}
evalplot.envSim.map(sim.type = "mess", ref.data = "occs", envs = envs, occs.z = occs.z, 
                    bg.z = bg.z, occs.grp = cb1.large$occs.grp, 
                    bg.grp = cb1$bg.grp, bb.buf = 7)
```

#### 3. Hierarchical checkerboard {#cb2}
The hierarchical checkerboard method partitions the data into *k* = 4 spatial groups. This is done by inputting two aggregation factors to hierarchically aggregate the input raster at two scales. Presence and background groups are assigned based on which box they fall into on the hierarchical checkerboard.

```{r part.ck2}
cb2 <- get.checkerboard(occs, envs.bg, bg, aggregation.factor = c(5,5))
evalplot.grps(pts = occs, pts.grp = cb2$occs.grp, envs = envs.bg)
# Plotting the background points shows the checkerboard pattern very clearly.
evalplot.grps(pts = bg, pts.grp = cb2$bg.grp, envs = envs.bg)
# Different from basic checkerboard, some partitions here do show some difference
# in environmental representation, but not as consistently different as with block.
evalplot.envSim.hist(sim.type = "mess", ref.data = "occs", occs.z = occs.z, 
                     bg.z = bg.z, occs.grp = cb2$occs.grp, bg.grp = cb2$bg.grp)
evalplot.envSim.map(sim.type = "mess", ref.data = "occs", envs = envs, occs.z = occs.z, 
                    bg.z = bg.z, occs.grp = cb2$occs.grp, 
                    bg.grp = cb2$bg.grp, bb.buf = 7)
```

#### 4. Jackknife (leave-one-out) {#jack}
The next two methods differ from the first three in that (a) they do not partition the background points into different groups (meaning that the full background is used to evaluate each partition), and (b) they do not account for spatial autocorrelation between validation and training localities. Primarily when working with relatively small data sets (e.g. < ca. 25 presence localities), users may choose a special case of *k*-fold cross-validation where the number of bins (*k*) is equal to the number of occurrence localities (*n*) in the data set (Pearson et al. 2007; Shcheglovitova & Anderson 2013). This is referred to as jackknife, or leave-one-out, partitioning (Hastie et al. 2009). As *n* models are processed with this partitioning method, the computation time could be long for large occurrence datasets. 

```{r part.jk}
jack <- get.jackknife(occs, bg)
# If the number of input points is larger than 10, the legend for the groups 
# is suppressed.
evalplot.grps(pts = occs, pts.grp = jack$occs.grp, envs = envs.bg)
```

#### 5. Random k-fold {#rand}
The 'random k-fold' method partitions occurrence localities randomly into a user-specified number of (*k*) bins (Hastie et al. 2009). This method is equivalent to the 'cross-validate' partitioning scheme available in the current version of the Maxent software GUI. Especially with larger occurrence datasets, this partitioning method could randomly result in some spatial clustering of groups, which is why spatial partitioning methods are preferable for addressing spatial autocorrelation (Roberts et al. 2017). Below, we partition the data into five random groups.

```{r part.rand}
rand <- get.randomkfold(occs, bg, k = 5)
evalplot.grps(pts = occs, pts.grp = rand$occs.grp, envs = envs.bg)
# As the partitions are random, there is no large environmental difference between them.
evalplot.envSim.hist(sim.type = "mess", ref.data = "occs", occs.z = occs.z, 
                     bg.z = bg.z, occs.grp = rand$occs.grp, bg.grp = rand$bg.grp)
```

```{r fig.width = 7, fig.height = 9}
evalplot.envSim.map(sim.type = "mess", ref.data = "occs", envs = envs, occs.z = occs.z, 
                    bg.z = bg.z, occs.grp = rand$occs.grp, 
                    bg.grp = rand$bg.grp, bb.buf = 7)
```

#### 6. Fully Withheld Testing Data {#testing}
The 'testing' method evaluates the model on a fully withheld testing dataset that is not used to create the full model (i.e., not included in the training data), meaning that cross validation statistics are not calculated. Evaluations with fully withheld testing data have been shown to result in models with better transferability (Soley-Guardia et al. 2019). 

To illustrate this, we will make a table containing occurrences representing both training data and fully withheld testing data (which we simulate) and plot the partitions in the same way as above. However, the testing data (group 2) will not become training data for a new model. Instead, the training data (group 1) is used to make the model, and the testing data (group 2) are used only to evaluate it. Thus, the background extent does not include the testing data (a few points fall inside this extent because of the buffer we applied, but they are not used as training data).

```{r part.ind}
# First, let's specify a fake testing occurrence dataset and plot the testing points with 
# the rest of our data
occs.testing <- data.frame(longitude = -runif(10, 55, 65), latitude = runif(10, -10, 0))
evalplot.grps(pts = rbind(occs, occs.testing), 
              pts.grp = c(rep(1, nrow(occs)), rep(2, nrow(occs.testing))), envs = envs.bg)
# Next, let's extract the predictor variable values for our testing points.
occs.testing.z <- cbind(occs.testing, terra::extract(envs, occs.testing, ID = FALSE))
# We use the same background groups as random partitions here because the background used 
# for testing data is also from the full study extent. We use here the occs.testing.z 
# parameter to add information for our testing localities, and we set the partitions 
# for occurrences all to zero (as no partitioning is done).
evalplot.envSim.hist(sim.type = "mess", ref.data = "occs", occs.z = occs.z, 
                     bg.z = bg.z, occs.grp = rep(0, nrow(occs)), 
                     bg.grp = rand$bg.grp, occs.testing.z = occs.testing.z)
```

```{r fig.width = 7, fig.height = 5}
evalplot.envSim.map(sim.type = "mess", ref.data = "occs", envs = envs, occs.z = occs.z, 
                    bg.z = bg.z, occs.grp = rep(0, nrow(occs)), bg.grp = rand$bg.grp, 
                    bb.buf = 7, occs.testing.z = occs.testing.z)
# We can see what is to be expected -- the testing dataset is much more restricted 
# environmentally than the training data, and thus is much more difference with the 
# study extent.
```

#### 7. User-defined {#user}
For maximum flexibility, the last partitioning method is designed so that users can define *a priori* partitions. This provides a flexible way to conduct spatially-independent cross-validation with background masking. For example, we demonstrate partitioning the occurrence data based on *k*-means groups. The user-defined partition option can also be used to input partition groups derived from other sources.

```{r part.user1}
# Here we run a k-means clustering algorithm to group our occurrences into discrete spatial 
# groups based on their coordinates.
grp.n <- 6
kmeans <- kmeans(occs, grp.n)
occs.grp <- kmeans$cluster
evalplot.grps(pts = occs, pts.grp = occs.grp, envs = envs.bg)
```

When using the user-defined partitioning method, we need to supply `ENMevaluate` with group identifiers for both occurrence AND background records If we want to use all background records for each group, we can set the background to zero.

```{r part.user2}
# Assign all background records
bg.grp <- rep(0, nrow(bg))
evalplot.grps(pts = bg, pts.grp = bg.grp, envs = envs.bg)
```

Alternatively, we may think of various ways to partition background data. This depends on the goals of the study but we might, for example, find it reasonable to partition background records by assigning groups based on distance to the centroids of the occurrence clusters.

```{r part.user3}
# Here we find the centers of the occurrence k-means clusters and calculate the spatial 
# distance of each background point to them. We then find which center had the minimum 
# distance for each record and assign that record to this centroid group.
centers <- kmeans$center
d <- raster::pointDistance(bg, centers, lonlat = TRUE)
bg.grp <- apply(d, 1, function(x) which(x == min(x)))
evalplot.grps(pts = bg, pts.grp = bg.grp, envs = envs.bg)
```

We can also use other packages to partition our data. As an example, we next show how to use the R package [`blockCV`](https://CRAN.R-project.org/package=blockCV) (Valavi et al. 2019) to generate spatial partitions to input into `ENMevaluate`. We use the `spatialBlock` function to generate blocks similar to the checkerboard partition in `ENMeval`, except that we choose here to select partitions randomly over these blocks. This package offers other kinds of block partitioning methods as well. Using other packages in this way expands the variety of partitions you can use to evaluate models in `ENMeval`, and we highly encourage experimenting with a plurality of tools.

```{r}
library(blockCV)
library(sf)

# First, we convert our occurrence and background records to spatial point data with the 
# package sf and assign the correct coordinate reference system.
occsBg.sf <- sf::st_as_sf(rbind(occs, bg), coords = c("longitude","latitude"), 
                          crs = "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs")
terra::crs(envs.bg) <- terra::crs(occsBg.sf)
# Here, we implement the spatialBlock function from the blockCV package.
# The required inputs are similar to ENMeval partitioning functions, but here you assign
# the size of blocks in meters with the argument theRange (here set at 1000 km), and the 
# partition selection method can be assigned as either "checkerboard" or "random"
# In addition, the spatialBlock function returns a map showing the different 
# spatial partitions.
sb <- blockCV::spatialBlock(speciesData = occsBg.sf, rasterLayer = envs.bg, 
                            theRange = 1000000, k = 5, selection = "random")
# We can pull out the partition information from the SpatialBlock object to assemble
# occs.grp and bg.grp, which can be used for plotting or as user.grp inputs for ENMevaluate.
occs.grp <- sb$foldID[1:nrow(occs)]
bg.grp <- sb$foldID[(nrow(occs)+1):length(sb$foldID)]
evalplot.grps(pts = bg, pts.grp = bg.grp, envs = envs.bg)
```

Selecting which of these data partitioning methods to use should be based on the research objectives and the characteristics of the study system. Refer to the [References and Resources](#resources) section for studies and resources to consult for more information concerning partitioning for model evaluation.

## Running ENMeval {#eval}
Once we decide which method of data partitioning we would like to use, we are ready to start building models. We now move on to the main function in `ENMeval`: `ENMevaluate`.

#### Initial considerations
Although any algorithm can potentially be specified in `ENMeval` 2.0.x (see below), and the package has built-in implementations for Maxent and BIOCLIM, we will explain here the tuning procedure for Maxent models (either `maxent.jar` or `maxnet`). For Maxent models (Phillips et al. 2006, Phillips et al. 2008, Phillips et al. 2017), the two main parameters to tune when calling `ENMevaluate` are (1) the range of regularization multiplier values and (2) the combinations of feature classes (Elith et al. 2011, Merow et al. 2013). The ***regularization multiplier*** (RM) determines the penalty associated with including variables or their transformations in the model. Higher RM values impose a stronger penalty on model complexity and thus result in simpler (*flatter*) model predictions. The ***feature classes*** determine the potential shape of the marginal response curves. A model that is only allowed to include linear feature classes will most likely be simpler than a model that is allowed to include all possible feature classes. A more detailed description of these parameters is available in the [References and Resources](#resources) section. For the purposes of this vignette, we demonstrate simply how to adjust these parameters. The following section deals with comparing the outputs of each model.

Unless you supply the function with background points (which is recommended in many cases), you will need to define how many background points should be used with the `n.bg` argument. If any of your predictor variables are categorical (e.g., like the "biomes" variable we initially removed from this dataset), you should define which layer(s) these are using the 'categoricals' argument or assign them as factors in the SpatRaster or input table.

`ENMevaluate` builds a separate model for each unique combination of RM values and feature class combinations. For example, the following call will build and evaluate 2 models. One with RM=1 and another with RM=2, both allowing only linear features.

```{r enmeval1, results='hide'}
e.mx.l <- ENMevaluate(occs = occs, envs = envs, bg = bg, 
                      algorithm = 'maxnet', partitions = 'block', 
                      tune.args = list(fc = "L", rm = 1:2))
```

```{r}
e.mx.l
```

We may, however, want to compare a wider range of models that can use a wider variety of feature classes and regularization multipliers:

```{r maxnet2, results='hide'}
tune.args <- list(fc = c("L","LQ","LQH","H"), rm = 1:5)
e.mx <- ENMevaluate(occs = occs, envs = envs, bg = bg, 
                    algorithm = 'maxnet', partitions = 'block', 
                    tune.args = tune.args)
```

```{r}
e.mx
```

When building many models, the function may take a long time to run. Of course this depends on the size of your dataset and the computer you are using. When working on big projects, running the command in parallel (`parallel = TRUE`) can be considerably faster. Note that running parallel can also be slower when working on small datasets.

We can also calculate one of two niche overlap statistics while running `ENMevaluate` by setting the arguments `overlap = TRUE` and `overlapStat`, which support Moran's I or Schoener's D (Warren et al. 2008). Note that you can also calculate this value at a later stage using the separate `calc.niche.overlap` function.

```{r maxnet2.overlap, results='hide'}
overlap <- calc.niche.overlap(e.mx@predictions, overlapStat = "D")
```

```{r}
overlap[1:5,]
```

#### Different parameterizations
There are multiple ways to run the function `ENMevaluate`, and we will go over how to specify each parameterization and what the effects are on the results.

```{r evalExamples, eval = FALSE}
# If maxent.jar is installed and rJava loads properly, you can also run Maxent with 
# the original Java software. You may need to run rJava::.jpackage('predicts') before
# running the model.
rJava::.jpackage('predicts')
e.mxjar <- ENMevaluate(occs, envs, bg, algorithm = "maxent.jar", 
                       tune.args = tune.args, partitions = "block")

# 2. Testing partition: no cross validation statistics calculated; instead, model will be 
# evaluated on a testing dataset that is not used to create the full model.
e.test <- ENMevaluate(occs, envs, bg, algorithm = "maxnet", 
                      tune.args = tune.args, partitions = "testing", 
                      occs.testing = occs.testing)

# 3. User partitions.
user.grp <- list(occs.grp = round(runif(nrow(occs), 1, 2)), 
                 bg.grp = round(runif(nrow(bg), 1, 2)))
e.user <- ENMevaluate(occs, envs, bg, algorithm = "maxnet", 
                      tune.args = tune.args, partitions = "user", user.grp = user.grp)

# 4. No partitions: no cross validation statistics calculated, nor any model 
# evaluation on test data.
e.noCV <- ENMevaluate(occs, envs, bg, algorithm = "maxnet", 
                      tune.args = tune.args, partitions = "none")

# 5. No raster data (a.k.a, samples with data, or SWD): no full model raster predictions 
# created, so will run faster; also, both cbi.train and cbi.val will be calculated on the 
# point data (training and validation background) instead of on the "envs" rasters (default).
# For this implementation, assigning categorical variables to factor with the argument 
# "categoricals" is easier, as ENMevaluate internally assigns the levels based on both 
# occs and bg, avoiding any errors associated with different factor levels when combining data.
occs.z <- cbind(occs, terra::extract(envs, occs, ID = FALSE))
bg.z <- cbind(bg, terra::extract(envs, bg, ID = FALSE))
e.swd <- ENMevaluate(occs.z, bg = bg.z, algorithm = "maxnet", tune.args = tune.args, 
                     partitions = "block")
```

You can also specify your own custom validation statistics for `ENMevaluate` to calculate and report in the results tables. This is done by defining a custom function that has the arguments shown below, which are used by the internal function `tune.validate`. Here, we add functionality to calculate the AUC ratio and associated p-value for the partial ROC perfomance metric, defined in (Peterson et al. 2008) and implemented by the R package `kuenm` (Cobos et al. 2019), which is currently only available on Github.

```{r eval = FALSE}
# First, make sure you install kuenm from Github.
devtools::install_github("marlonecobos/kuenm")
# Define a custom function that implements a performance metric not included in ENMeval.
# The function should have a single argument "vars", which is a list that includes the 
# data most performance metrics should require -- the total list of these data can be found 
# here: ?ENMevaluate. Make sure you return a data frame that specifies the names you want to 
# see in the results tables.
proc <- function(vars) {
  proc <- kuenm::kuenm_proc(vars$occs.val.pred, c(vars$bg.train.pred, vars$bg.val.pred))
  out <- data.frame(proc_auc_ratio = proc$pROC_summary[1], 
                    proc_pval = proc$pROC_summary[2], row.names = NULL)
  return(out)
}

# Now we can run ENMevaluate with the argument "user.eval", and simply give it the 
# custom function.
e.mx.proc <- ENMevaluate(occs, envs, bg, algorithm = "maxnet", 
                         tune.args = list(fc = "L", rm = 1:2), 
                         partitions = "block", user.eval = proc)
```

```{r include = FALSE}
e.mx.proc <- readRDS("e_mx_proc.rds")
```

We can see the new performance statistic averages in the `results` slot. Notice that some model settings have NA values for validation statistics -- this is because one or more models were NULL when built during cross-validation. If this is the case, it means the training data used by the model (which was missing the withheld fold) may have provided insufficient information for model convergence given the assigned settings. Other cross-validation methods might result in fewer model errors because they partition the data differently. To see the model performance for all the folds, look at the `results.partitions` slot.
```{r}
e.mx.proc@results
e.mx.proc@results.partitions
```

Yet another way to run `ENMevaluate` is by specifying a new algorithm using the `ENMdetails` object. Built-in algorithms (maxent.jar, maxnet, BIOCLIM) are implemented as `ENMdetails` objects---they can be found in the /R folder of the package with the file name "enm.name", where "name" is the algorithm. The `ENMdetails` object specifies the way `ENMevaluate` should run the algorithm. It has some simple functions that output 1) the algorithm's name, 2) the function that runs the algorithm, 3) particular messages or errors, 4) the arguments for the model's function, 5) a specific parameterization of the `predict` function, 6) the number of non-zero model coefficients, and 7) the variable importance table (if one is available from the model object). 

Users can construct their own `ENMdetails` object using the built-in ones as guides. For example, a user can copy the "enm.maxnet.R" script, modify the code to specify a different model, save it as a new script in the /R folder with the name "enm.myAlgorithm", and use it to run `ENMevaluate`. To be able to specify the model with the `algorithm` argument in `ENMevaluate`, a small modification needs to be made to add it to list in the `lookup.enm` internal function found in "R/utilities.R". We plan to work with other research groups to identify best practices for tuning other algorithms with presence-background/pseudoabsence data and implement new algorithms in ENMeval in the future.


#### Exploring the results
Now let's take a look at the output from `ENMevaluate`, which is an `ENMevaluation` object, in more detail (also see `?ENMevaluation`).  It contains the following slots:

- `algorithm` A character vector showing which algorithm was used
- `tune.settings` A data.frame of settings that were tuned
- `partition.method` A character of partitioning method used
- `partition.settings` A list of partition settings used (i.e., value of *k* or aggregation factor)
- `other.settings` A list of other modeling settings used (i.e., decisions about clamping, AUC diff calculation)
- `doClamp` A logical indicating whether or not clamping was used 
- `clamp.directions` A list of the clamping directions specified 
- `results` A data.frame of evaluation summary statistics
- `results.partitions` A data.frame of evaluation k-fold statistics
- `models` A list of model objects
- `variable.importance` A list of data frames with variable importance for each model (when applicable)
- `predictions` A SpatRaster of model predictions
- `taxon.name` A character for taxon name (when specified)
- `occs` A data frame of the occurrence record coordinates used for model training
- `occs.testing` A data frame of the coordinates of the fully withheld testing records (when specified)
- `occs.grp` A vector of partition groups for occurrence records
- `bg` A data frame of background record coordinates used for model training
- `bg.grp` A vector of partition groups for background records
- `overlap` A list of matrices of pairwise niche overlap statistics
- `rmm` A list of rangeModelMetadata objects for each model

Let's first examine the structure of the object.
```{r results1}
e.mx
# Simplify the summary to look at higher level items.
str(e.mx, max.level=2)
```

We can use helper functions to access the slots in the `ENMevaluation` object.
```{r algorithm}
# Access algorithm, tuning settings, and partition method information.
eval.algorithm(e.mx)
eval.tune.settings(e.mx) |> head()
eval.partition.method(e.mx)
# Results table with summary statistics for cross validation on test data.
eval.results(e.mx) |> head()
# Results table with cross validation statistics for each test partition.
eval.results.partitions(e.mx) |> head()
# List of models with names corresponding to tune.args column label.
eval.models(e.mx) |> str(max.level = 1)
# The "betas" slot in a maxnet model is a named vector of the variable 
# coefficients and what kind they are (in R formula notation).
# Note that the html file that is created when maxent.jar is run is **not** kept.
m1.mx <- eval.models(e.mx)[["fc.LQH_rm.1"]]
m1.mx$betas
# the enframe function from the tibble package makes this named vector into a 
# more readable table.
library(tibble)
enframe(m1.mx$betas)
# SpatRaster of model predictions (for extent of "envs") with names corresponding 
# to tune.args column label.
eval.predictions(e.mx)
# Original occurrence data coordinates with associated predictor variable values.
eval.occs(e.mx) |> head()
# Background data coordinates with associated predictor variable values.
eval.bg(e.mx) |> head()
# Partition group assignments for occurrence data.
eval.occs.grp(e.mx) |> str()
# Partition group assignments for background data.
eval.bg.grp(e.mx) |> str()
```

Maxent models run with `maxent.jar` have a different structure from models run with `maxnet`, so below is a demonstration of how to extract the "betas" information for `maxent.jar` models. In the case that the user can run `maxent.jar`, please run these lines independently. As many users have issues running the Java version of Maxent, this portion is not automatically evaluated for the vignette to avoid R Markdown knitting errors.

```{r, eval = FALSE}
# NOTE -- This code is not evaluated and so will display no output in this vignette.
# Please run independently.

# For maxent.jar models, we can access this information in the lambdas slot.
m1.mxjar <- e.mxjar@models$fc.LQ_rm.1
m1.mxjar@lambdas
```


```{r, eval = FALSE}
# The notation used here is difficult to decipher, so check out the 
# [`rmaxent`](https://github.com/johnbaums/rmaxent/blob/master/) package.
# available on Github for the `parse_lambdas()` function.
parse_lambdas(m1.mxjar)
```


```{r, eval = FALSE}
# We can also get a long list of results statistics from the results slot.
m1.mxjar@results
```

## Visualizing tuning results {#plot}

`ENMeval` 2.0.x has a built-in plotting function (`eval.plot`) to visualize the results of the different models you tuned in a ggplot. Here, we will plot average validation AUC and omission rates for the models we tuned. The x-axis is the regularization multiplier, and the color of the points and lines represents the feature class. Notice that models with NA scores for cross-validation are not plotted here, so hinge models with rm 2 and higher are not shown because they had errors during cross-validation.

```{r plot.res}
evalplot.stats(e = e.mx, stats = "or.mtp", color = "fc", x.var = "rm")
# We can plot more than one statistic at once with ggplot facetting.
evalplot.stats(e = e.mx, stats = c("or.mtp", "auc.val"), color = "fc", x.var = "rm")
# Sometimes the error bars make it hard to visualize the plot, so we can try turning them off.
evalplot.stats(e = e.mx, stats = c("or.mtp", "auc.val"), color = "fc", x.var = "rm", 
               error.bars = FALSE)
# We can also fiddle with the dodge argument to jitter the positions of overlapping points.
evalplot.stats(e = e.mx, stats = c("or.mtp", "auc.val"), color = "fc", x.var = "rm", 
               dodge = 0.5)
# Finally, we can switch which variables are on the x-axis and which symbolized by color.
# ENMeval currently only accepts two variables for plotting at a time.
evalplot.stats(e = e.mx, stats = c("or.mtp", "auc.val"), color = "rm", x.var = "fc", 
               error.bars = FALSE)
```

## Model selection {#select}

Once we have our results, we will want to select one or more models that we think are optimal across all the models we ran. For this example, we will demonstrate how to select models without considering cross-validation results using AICc (Warren & Seifert 2011; but see Velasco & GonzÃ¡lez-Salazar 2019) and a sequential method that uses cross-validation results by selecting models with the lowest average 10 percentile omission rate, and to break ties, with the highest average validation Continuous Boyce Index (Hirzel et al. 2006) calculated with the function from the R package `ecospat` (Di Cola et al. 2017). Concerning AUC, Lobo et al. (2008) and others have pointed out that validation AUC is inappropriate as an absolute performance measure of presence-background ENMs, but it is valid to use for relative comparisons of models constructed with the same data (Radosavljevic & Anderson 2014). Thus, it can be used as well to choose models, though it is typically correlated with CBI.

```{r evaluations}
# Overall results
res <- eval.results(e.mx)
# Select the model with delta AICc equal to 0, or the one with the lowest AICc score.
# In practice, models with delta AICc scores less than 2 are usually considered 
# statistically equivalent.
opt.aicc <- res |> filter(delta.AICc == 0)
opt.aicc
# This dplyr operation executes the sequential criteria explained above, but
# first removes settings with NA values for omission rate.
opt.seq <- res |> 
  filter(!is.na(or.10p.avg)) |>
  filter(or.10p.avg == min(or.10p.avg)) |> 
  filter(cbi.val.avg == max(cbi.val.avg))
opt.seq
```

Let's now choose the optimal model settings based on the sequential criteria and examine it.
```{r mod.obj1}
# We can select a single model from the ENMevaluation object using the tune.args of our
# optimal model.
mod.seq <- eval.models(e.mx)[[opt.seq$tune.args]]
# Here are the non-zero coefficients in our model.
mod.seq$betas
# And these are the marginal response curves for the predictor variables wit non-zero 
# coefficients in our model. We define the y-axis to be the cloglog transformation, which
# is an approximation of occurrence probability (with assumptions) bounded by 0 and 1
# (Phillips et al. 2017).
plot(mod.seq, type = "cloglog")
# The above function plots with graphical customizations to include multiple plots on 
# the same page. 
# Clear the graphics device to avoid plotting sequential plots with these settings.
dev.off()
```

This is how to view the marginal response curves for `maxent.jar` models.

```{r, eval = FALSE}
# NOTE -- This code is not evaluated and so will display no output in this vignette.
# Please run independently.

# maxent.jar models use the predicts::partialResponse() function for this
pr <- predicts::partialResponse(e.mxjar@models[[opt.seq$tune.args]],
                                var = "bio5")
plot(pr, type = "l", las = 1)
```

Now we plot and inspect the prediction raster for our optimal model. Note that by default for `maxent.jar` (versions >3.3.3k) or `maxnet` models, these predictions are in the 'cloglog' output format that is bounded between 0 and 1 (Phillips et al. 2017). This can be changed with the `pred.type` argument in `ENMevaluate`.

These predictions are for the entire extent of the input predictor variable rasters, and thus include areas outside of the background extent used for model training. Thus, we should interpret areas far outside this extent with caution.

```{r plotPred}
# We can select the model predictions for our optimal model the same way we did for the 
# model object above.
pred.seq <- eval.predictions(e.mx)[[as.character(opt.seq$tune.args)]]
plot(pred.seq, col = terrain.colors(100))

# We can also plot the binned background points with the occurrence points on top to 
# visualize where the training data is located.
points(eval.bg(e.mx), pch = 3, col = eval.bg.grp(e.mx), cex = 0.5)
points(eval.occs(e.mx), pch = 21, bg = eval.occs.grp(e.mx))
```

Let us now explore how model complexity changes the predictions in our example. We will compare the simple model built with only linear feature classes and the highest regularization multiplier value we used (fc='L', rm=5) with the complex model built with linear, quadratic, and hinge feature classes and the lowest regularization multiplier value we used (fc='LQH', rm=1). We will first examine the marginal response curves, and then the mapped model model predictions. Notice how the simpler models tend to have more smooth predictions of suitability, while the complex ones tend to show more patchiness. Deciding on whether a model that is more simple or complex is appropriate for your study is not straightforward, but guides exist in the literature (e.g., Merow et al. 2014). 

```{r plot.pred2}
# First, let's examine the non-zero model coefficients in the betas slot.
# The simpler model has fewer model coefficients.
mod.simple <- eval.models(e.mx)[['fc.L_rm.5']]
mod.complex <- eval.models(e.mx)[['fc.LQH_rm.1']]
mod.simple$betas
length(mod.simple$betas)
mod.complex$betas
length(mod.complex$betas)
# Next, let's take a look at the marginal response curves.
# The complex model has marginal responses with more curves (from quadratic terms) and 
# spikes (from hinge terms).
plot(mod.simple, type = "cloglog")
plot(mod.complex, type = "cloglog")
# To get the data for the marginal response curves from a maxnet model, use the 
# following code. You can then plot them any way you want.
mod.complex.mrc <-maxnet::response.plot(mod.complex, 
                                        v = "bio2", 
                                        type = "cloglog",
                                        plot = FALSE)
library(ggplot2)
ggplot(mod.complex.mrc, aes(x = bio2, y = pred)) + 
  geom_line() + ylab("cloglog prediction") + theme_bw()
# Finally, let's cut the plotting area into two rows to visualize the predictions 
# side-by-side.
par(mfrow = c(2,1), mar = c(2,1,2,0))
# The simplest model: linear features only and high regularization.
plot(eval.predictions(e.mx)[['fc.L_rm.5']], ylim = c(-30,20), xlim = c(-90,-30), 
     main = 'L_5 prediction', col = terrain.colors(100))
# The most complex model: linear, quadratic, and hinge features with low regularization
plot(eval.predictions(e.mx)[['fc.LQH_rm.1']], ylim = c(-30,20), xlim = c(-90,-30), 
     main = 'LQH_1 prediction', col = terrain.colors(100))
```

## Null models {#null}

We were able to calculate performance metrics for our model, such as omission rates and AUC, but we do not know how they compare to the same metrics calculated on null models built with random data. This information would allow us to determine the significance and effect sizes of these metrics. If the metrics we calculated for our empirical model were not significantly different from those calculated for a series of null models, we would have not have high confidence that they meaningfully represent how well our empirical model performed. Raes & ter Steege (2007) first introduced the concept of a null ENM and demonstrated how it can be applied. This approach sampled random occurrence records from the study extent and evaluated null models with random cross-validation. Since then some enhancements have been made to this original approach. One such modification was implemented by Bohl et al. (2019), who proposed evaluating models on the same withheld occurrence data as the empirical model. This approach allows for direct comparisons between null performance metrics and those of the emprical models. Kass et al. (2020) further extended this method by configuring it to calculate null performance metrics using spatial partitions.

`ENMeval` 2.0.x has the functionality to run null ENMs using the Bohl et al. method with the Kass et al. extension and visualize the performance of the empirical model against the null model averages.

```{r, echo = FALSE}
mod.null <- readRDS("mod_null.rds")
```

```{r, eval = FALSE}
# We first run the null simulations with 100 iterations to get a reasonable null distribution 
# for comparisons with the empirical values
mod.null <- ENMnulls(e.mx, mod.settings = list(fc = "LQH", rm = 3), no.iter = 100)
```

```{r}
# We can inspect the results of each null simulation.
null.results(mod.null) |> head()
# And even inspect the results of each partition of each null simulation.
null.results.partitions(mod.null) |> head()
# For a summary, we can look at a comparison between the empirical and simulated results.
null.emp.results(mod.null)
# Finally, we can make plots of the null model results as a histogram. In this
# example, the empirical validation CBI value (solid red line) is significantly 
# higher than random, as it is higher than the 99th quantile of the null values
# (dashed purple line). For reference, this plot also includes the null 95th 
# quantile (dashed blue line) and the null mean (solid blue line). For more 
# details, please see ?evalplot.nulls.
evalplot.nulls(mod.null, stats = c("or.10p", "cbi.val"), plot.type = "histogram")
# Or we can visualize the results with a violin plot. The red point shows the 
# empirical value and the shape shows the density of the null distribution
# with lines denoting the quantiles.
evalplot.nulls(mod.null, stats = c("or.10p", "cbi.val"), plot.type = "violin")
```

## Metadata {#metadata}

The last point this vignette will discuss is extremely important for all scientific research: reproducibility. `ENMeval` 2.0.x now catalogs details of the analysis essential for reproducibility in a `rangeModelMetadata` object, accessible from the output `ENMevaluation` object. The framework and philosophy behind `rangeModelMetadata` is described by Merow et al. (2019), and other related efforts to define crucial metadata standards and rating systems for ENMs have come out since (e.g., AraÃºjo et al. 2019, Feng et al. 2019, Zurell et al. 2020). Metadata generated by `ENMeval` can be saved to a CSV file for sharing with collaborators or for use in supplemental information for a manuscript, etc.

```{r}
# Generate a rangeModelMetadata object based on the information stored in the 
# ENMevaluate object.
rmm <- eval.rmm(e.mx)
# We can fill in the model selection rules based on the sequential criteria we chose.
rmm$model$selectionRules <- "lowest 10 percentile omission rate, 
break ties with average validation AUC"
# We can also enter our optimal model settings and the details of our optimal 
# model's prediction.
rmm$model$finalModelSettings <- "LQ2"
rmm$prediction$continuous$minVal <- terra::global(pred.seq, min)
rmm$prediction$continuous$maxVal <- terra::global(pred.seq, max)
rmm$prediction$continuous$units <- "suitability (cloglog transformation)"
# This is just an example -- there may be more fields relevant to fill in for your study.
```

```{r, eval = FALSE}
# Finally, we can save the metadata to a CSV file.
rangeModelMetadata::rmmToCSV(rmm, "rmm_mx1.csv")
```


## References and Resources {#resources}

This list of references and resources is not exhaustive by any means, and mainly includes those sources we referenced in the vignette text. The field is expanding further every year, and there are many other papers and packages that one learning about ENMs should explore.

###### Web Resources
- [Hijmans, R. & Elith, J. (2021) Species distribution modeling.](https://rspatial.org/raster/sdm/)

- [Maxent Google Group](https://groups.google.com/forum/embed/#!forum/maxent)

- [Phillips, S. J. (2021) A brief tutorial on Maxent. AT&T Research. Available at: https://biodiversityinformatics.amnh.org/open_source/maxent/Maxent_tutorial_2021.pdf](https://biodiversityinformatics.amnh.org/open_source/maxent/Maxent_tutorial_2021.pdf)

- [Yoder, J. (2013). Species distribution models in R. The Molecular Ecologist.](https://www.molecularecologist.com/2013/04/species-distribution-models-in-r/)

###### General Guides

- [AraÃºjo, M. B., Anderson, R. P., Barbosa, A. M., Beale, C. M., Dormann, C. F., Early, R., Garcia, R. A., Guisan, A., Maiorano, L., Naimi, B., & OâHara, R. B. (2019). Standards for distribution models in biodiversity assessments. Science Advances, 5: eaat4858.](https://doi.org/10.1126/sciadv.aat4858)

- [Franklin, J. (2010). Mapping species distributions: spatial inference and prediction. Cambridge University Press.](https://doi.org/10.1017/CBO9780511810602)

- [Guisan A., Thuiller W., & Zimmermann N. E. (2017). Habitat Suitability and Distribution Models with Applications in R. Cambridge University Press, Cambridge, UK.](https://doi.org/10.1017/9781139028271)

- [Merow, C., Smith, M. J., Edwards Jr, T. C., Guisan, A., McMahon, S. M., Normand, S., Thuiller, W., WÃ¼est, R. O., Zimmermann, N. E., & Elith, J. (2014). What do we gain from simplicity versus complexity in species distribution models? Ecography, 37: 1267â1281.](https://doi.org/10.1111/ecog.00845)

- [Peterson, A.T., SoberÃ³n, J., Pearson, R.G., Anderson, R.P., MartÃ­nez-Meyer, E., Nakamura, M., & AraÃºjo, M.B. (2011) Ecological Niches and Geographic Distributions. Monographs in Population Biology, 49. Princeton University Press.](https://press.princeton.edu/titles/9641.html)

-[VanDerWal, J., Shoo, L. P., Graham, C., & Williams, S. E. (2009). Selecting pseudo-absence data for presence-only distribution modeling: how far should you stray from what you know?. Ecological Modelling, 220: 589-594.](https://doi.org/10.1016/j.ecolmodel.2008.11.010)

###### Maxent

- [Elith, J., Phillips, S. J., Hastie, T., DudÃ­k, M., Chee, Y. E., & Yates, C. J. (2011). A statistical explanation of MaxEnt for ecologists. Diversity and Distributions, 17(1), 43-57.](https://doi.org/10.1111/j.1472-4642.2010.00725.x)

- [Merow, C., Smith, M., & Silander, J.A. (2013). A practical guide to Maxent: what it does, and why inputs and settings matter. Ecography, 36, 1-12.](https://onlinelibrary.wiley.com/doi/abs/10.1111/j.1600-0587.2013.07872.x)

- [Phillips, S. J., Anderson, R. P., & Schapire, R. E. (2006). Maximum entropy modeling of species geographic distributions. Ecological Modelling, 190: 231â259.](https://doi.org/10.1016/j.ecolmodel.2005.03.026)

- [Phillips, S. J., & DudÃ­k, M. (2008). Modeling of species distributions with Maxent: new extensions and a comprehensive evaluation. Ecography, 31: 161-175.](https://doi.org/10.1111/j.0906-7590.2008.5203.x)

- [Phillips, S. J., Anderson, R. P., DudÃ­k, M., Schapire, R. E., & Blair, M. E. (2017). Opening the black box: an open-source release of Maxent. Ecography, 40: 887â893.](https://doi.org/10.1111/ecog.03049)

###### Environmental and Niche Similarity

- [Elith, J., Kearney, M., & Phillips, S. (2010). The art of modelling rangeâshifting species. Methods in Ecology and Evolution, 1(4), 330-342.](https://doi.org/10.1111/j.2041-210X.2010.00036.x)

- [Fitzpatrick, M. C., & Hargrove, W. W. (2009). The projection of species distribution models and the problem of non-analog climate. Biodiversity and Conservation, 18(8), 2255-2261.](https://doi.org/10.1007/s10531-009-9584-8)

- [Mesgaran, M. B., Cousens, R. D., & Webber, B. L. (2014). Here be dragons: a tool for quantifying novelty due to covariate range and correlation change when projecting species distribution models. Diversity and Distributions, 20: 1147-1159.](https://doi.org/10.1111/ddi.12209)

- [Owens, H. L., Campbell, L. P., Dornak, L. L., Saupe, E. E., Barve, N., SoberÃ³n, J., ... & Peterson, A. T. (2013). Constraints on interpretation of ecological niche models by limited environmental ranges on calibration areas. Ecological Modelling, 263, 10-18.](https://doi.org/10.1016/j.ecolmodel.2013.04.011)

- [Warren, D. L., Glor, R. E., & Turelli, M. (2008). Environmental niche equivalency versus conservatism: quantitative approaches to niche evolution. Evolution: International Journal of Organic Evolution, 62: 2868-2883.](https://dx.doi.org/10.1111/j.1558-5646.2008.00482.x)


###### Model Evaluation

- [Aiello-Lammens, M.E., Boria, R.A., Radosavljevic, A., Vilela, B., & Anderson, R.P. (2015) spThin: an R package for spatial thinning of species occurrence records for use in ecological niche models. Ecography, 38, 541-545.](https://onlinelibrary.wiley.com/doi/abs/10.1111/ecog.01132)

- [Fielding, A.H. & Bell, J.F. (1997). A review of methods for the assessment of prediction errors in conservation presence-absence models. Environmental Conservation 24, 38-49.](https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.463.359&rep=rep1&type=pdf)

- [Hallgren, W., Santana, F., Low-Choy, S., Zhao, Y., & Mackey, B. (2019). Species distribution models can be highly sensitive to algorithm configuration. Ecological Modelling, 408: 108719.](https://doi.org/10.1016/j.ecolmodel.2019.108719)

- [Hastie, T., Tibshirani, R., & Friedman, J. (2009). The Elements of Statistical Learning: Data Mining, Inference, and Prediction. Springer, New York, NY.](https://web.stanford.edu/~hastie/ElemStatLearn/)

- [Hirzel, A. H., Le Lay, G., Helfer, V., Randin, C., & Guisan, A. (2006). Evaluating the ability of habitat suitability models to predict species presences. Ecological Modelling, 199: 142-152.](https://doi.org/10.1016/j.ecolmodel.2006.05.017)

- [Kass, J. M., Anderson, R. P., EspinosaâLucas, A., JuÃ¡rezâJaimes, V., MartÃ­nezâSalas, E., Botello, F., Tavera, G., FloresâMartÃ­nez, J. J., & SÃ¡nchezâCordero, V. (2020). Biotic predictors with phenological information improve range estimates for migrating monarch butterflies in Mexico. Ecography, 43(3), 341-352.](https://doi.org/10.1111/ecog.04886)

- [Lobo, J. M., JimÃ©nezâValverde, A., & Real, R. (2008). AUC: a misleading measure of the performance of predictive distribution models. Global ecology and Biogeography, 17: 145-151.](https://doi.org/10.1111/j.1466-8238.2007.00358.x)

- [Pearson, R.G., Raxworthy, C.J., Nakamura, M., & Peterson, A.T. (2007) Predicting species distributions from small numbers of occurrence records: a test case using cryptic geckos in Madagascar. Journal of Biogeography 34, 102-117.](https://doi.org/10.1111/j.1365-2699.2006.01594.x)

- [Peterson, A. T., PapeÅ, M., & SoberÃ³n, J. (2008). Rethinking receiver operating characteristic analysis applications in ecological niche modeling. Ecological Modelling, 213: 63-72.](http://dx.doi.org/10.1016/j.ecolmodel.2007.11.008)

- [Radosavljevic, A. & Anderson, R.P. (2014). Making better Maxent models of species distributions: complexity, overfitting and evaluation. Journal of Biogeography 41, 629-643.](https://onlinelibrary.wiley.com/doi/abs/10.1111/jbi.12227)

- [Roberts, D. R., Bahn, V., Ciuti, S., Boyce, M. S., Elith, J., GuilleraâArroita, G., Hauenstein, S., LahozâMonfort, J. J., SchrÃ¶der, B., Thuiller, W., & Warton, D. I. (2017). Cross-validation strategies for data with temporal, spatial, hierarchical, or phylogenetic structure. Ecography, 40: 913â929.](https://doi.org/10.1111/ecog.02881)

- [Shcheglovitova, M. & Anderson, R.P. (2013). Estimating optimal complexity for ecological niche models: A jackknife approach for species with small sample sizes. Ecological Modelling 269: 9-17.](https://www.sciencedirect.com/science/article/pii/S0304380013004043)

- [Velasco, J. A. & GonzÃ¡lez-Salazar, C. (2019). Akaike information criterion should not be a âtestâ of geographical prediction accuracy in ecological niche modelling. Ecological Informatics, 51: 25â32.](https://doi.org/10.1016/j.ecoinf.2019.02.005)

- [Veloz, S.D. (2009) Spatially autocorrelated sampling falsely inflates measures of accuracy for presence-only niche models. Journal of Biogeography 36: 2290-2299.](https://onlinelibrary.wiley.com/doi/abs/10.1111/j.1365-2699.2009.02174.x)

- [Warren, D. L. & Seifert, S. N. (2011). Ecological niche modeling in Maxent: the importance of model complexity and the performance of model selection criteria. Ecological Applications, 21: 335â342.](https://doi.org/10.1890/10-1171.1)

###### Null ENMs

- [Bohl, C. L., Kass, J. M., & Anderson, R. P. (2019). A new null model approach to quantify performance and significance for ecological niche models of species distributions. Journal of Biogeography, 46: 1101-1111.](https://doi.org/10.1111/jbi.13573)

- [Raes, N., & ter Steege, H. (2007). A null-model for significance testing of presence-only species distribution models. Ecography, 30(5), 727-736.](https://www.jstor.org/stable/30244521)

###### Model Transfer

- [Soley-Guardia, M., Carnaval, A. C., & Anderson, R. P. (2019). Sufficient versus optimal climatic stability during the Late Quaternary: using environmental quality to guide phylogeographic inferences in a Neotropical montane system. Journal of Mammalogy, 100: 1783â1807.](https://doi.org/10.1093/jmammal/gyz162)

- [Wenger, S.J. & Olden, J.D. (2012) Assessing transferability of ecological models: an underappreciated aspect of statistical validation. Methods in Ecology and Evolution, 3: 260-267.](https://besjournals.onlinelibrary.wiley.com/doi/abs/10.1111/j.2041-210X.2011.00170.x)

- [Wright, A. N., Hijmans, R. J., Schwartz, M. W., & Shaffer, H. B. (2015). Multiple sources of uncertainty affect metrics for ranking conservation risk under climate change. Diversity and Distributions, 21(1), 111-122.](https://doi.org/10.1111/ddi.12257)

###### Metadata

- [Feng, X., Park, D. S., Walker, C., Peterson, A. T., Merow, C., & PapeÅ, M. (2019). A checklist for maximizing reproducibility of ecological niche models. Nature Ecology and Evolution, 3: 1382â1395.](https://doi.org/10.1038/s41559-019-0972-5)

- [Merow, C., Maitner, B. S., Owens, H. L., Kass, J. M., Enquist, B. J., Jetz, W., & Guralnick, R. (2019). Speciesâ range model metadata standards: RMMS. Global Ecology and Biogeography, 28: 1912â1924.](https://doi.org/10.1111/geb.12993)

- [Zurell, D., Franklin, J., KÃ¶nig, C., Bouchet, P. J., Dormann, C. F., Elith, J., Fandos, G., Feng, X., GuilleraâArroita, G., Guisan, A. & LahozâMonfort, J. J. (2020). A standard protocol for reporting species distribution models. Ecography, 43: 1261â1277.](https://doi.org/10.1111/ecog.04960)

###### R Packages for ENMs

- Baumgartner, J., & Wilson, P. (2021). _rmaxent: Tools for working with Maxent in R_. R package version 0.8.5.9000, URL:
[https://github.com/johnbaums/rmaxent](https://github.com/johnbaums/rmaxent).

- [Cobos, M. E., Peterson, A. T., Barve, N., & Osorio-Olvera, L. (2019). kuenm: an R package for detailed development of ecological niche models using Maxent. PeerJ, 7: e6281](http://dx.doi.org/10.7717/peerj.6281)

- [Di Cola, V., Broennimann, O., Petitpierre, B., Breiner, F. T., d'Amen, M., Randin, C., ... & Guisan, A. (2017). ecospat: an R package to support spatial analyses and modeling of species niches and distributions. Ecography, 40(6), 774-787.](https://doi.org/10.1111/ecog.02671)

- [Muscarella, R., Galante, P. J., Soley-Guardia, M., Boria, R. A., Kass, J. M., Uriarte, M. & Anderson, R. P. (2014). ENMeval: An R package for conducting spatially independent evaluations and estimating optimal model complexity for Maxent ecological niche models. Methods in Ecology and Evolution, 5: 1198â1205.](https://doi.org/10.1111/2041-210X.12261)

- [Valavi, R., Elith, J., Lahoz-Monfort, J. J., & Guillera-Arroita G. (2019) blockCV: An R package for generating spatially or environmentally separated folds for k-fold cross-validation of species distribution models. Methods in Ecology and Evolution, 10:225â232.](https://doi.org/10.1111/2041-210X.13107)
  
- Wickham H. (2016). ggplot2: Elegant Graphics for Data Analysis. Springer-Verlag New York. [https://ggplot2.tidyverse.org](https://ggplot2.tidyverse.org). 

